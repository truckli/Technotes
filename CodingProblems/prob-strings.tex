%!Mode:: "TeX:UTF-8"
\section{字符串问题举例}

\subsection{字符串移位包含问题}
\cite{bop}3.1。串A看作环形，是否包含串B。判断A+A是否包含B即可。


\subsection{词典聚类:变位词和电话键盘}
\cite{pp}2.4, 2.6.1。找出词典中所有互为变位词的集合，以及给定单词找出字典中所有它的变位词。词典中所有单词计算其标识，使得所有变位词具有相同标识。标识与单词构成元组，基于该标识对各元组排序，即可将所有变位词聚类。对于后一问题，可以按照前一个问题对各元组排序，执行词典预处理，这样就能使用二分搜索。实际系统往往使用散列技术或数据库系统(\cite{pp}2.6.6答案)。标识可以是单词内对字母按照字母表排序后形成的字符串。可以推广到对数据库中元组基于某规则进行归类。例如将将名字映射为拨号按键序列的问题(\cite{bop}3.2,\cite{pp}2.6.6, \cite{pie})求解所有映射成相同序列的名字，以及给定序列返回所有对应名字，此时标识就是按键序列。
\label{problem:dictClassify}

\subsection{字串枚举:电话号码对应英文单词}
\cite{bop}3.2, \cite{pie}P119\\
问题1：枚举一个电话号码能够构成的所有字母组合，普通枚举问题。问题2:基于词典，一个给定电话号码是否构成有意义的单词。方法一：基于问题1的解答，将每个答案同词典进行匹配，需要遍历词典很多次。方法二：将可以构成单词的电话号码预先存放到数字词典中。方法三:实质可看作词典聚类问题，参\ref{problem:dictClassify}，遍历一遍词典，判断每个单词是否符合这个电话号。
\label{question:phonekeyboard}

\subsection{文档词频统计}
\cite{pp}15.1。不基于词典，单词词形没有限制。利用散列表存储每个单词的词频，表的长度为质数29989，使哈希载荷因子接近1(圣经中有29121个单词，区分大小写)，用链表解决冲突。每次查询几乎为常数时间。总时间正比于文档长度。

\subsection{至少重复两次短语最大长度}
\cite{pp}15.2。此题没有单词的概念，只有字符。基于双指针同向扫描的算法需要平方时间。可以采用后缀数组，数组中每个元素为指针，指向文档中每个字符，相当于文档的每一个后缀都在数组中有所对应。然后基于对指针指向的字符串的比较，对后缀数组排序。扫描排序后的后缀数组，查看当前字符串与下一个字符串的共同前缀长度，找最大值。如果字符串比较的时间看作常数，那么总开销取决于排序，为线性乘以对数时间。然而，如果文档所有字符都一样，或者文档是由另一个文档复制了两次而来，那么字符串比较的时间和计算共同前缀的时间可能会正比于文档长度。

扩展:至少重复K次的最长短语(\cite{pp}15.5.8)。 同样对后缀数组排序，扫描后缀数组，查看当前字符串和后面第K-1个字符串的共同前缀长度，这两个字符串的共同前缀也是中间K-2个字符串的前缀，找最大值。

\label{problem:maxlenphrase}。

\subsection{K单词马尔可夫文本预测}
\cite{pp}15.3。基于当前位置K个单词预测下一个单词。在学习阶段，对训练文档，建立后缀数组(参\ref{problem:maxlenphrase})并排序，本题后缀数组的每个指针元素指向文档的各单词，而不是指向所有字符。同时，比较函数也改为，如果前K个单词相同则断定字符串相同)扫描后缀数组。在预测阶段，对于给定K单词短语，利用二分搜索在对数时间内定位到后缀数组中有相同K单词前缀的字符串(if any)，在这些字符串中随机选择一个，输出该字符串的下一个单词即可。作为优化(\cite{pp}15.5.8)，不对后缀数组进行排序，而是将每个后缀的位置存放在散列表中，使得具有相同K单词前缀的后缀在同一个散列表项中。这样，在预测阶段只用常数时间即可完成对给定短语的搜索。 


\subsection{最长公共子序列LCS}
算法导论动态规划章，子序列不需连续。

$LCS[x][y]= \left\{ \begin{array}{l} LCS[x-1][y-1]+1, A[x]=B[y] \\ max\{LCS[x][y-1], LCS[x-1][y]\}, A[X] \ne B[y] \end{array}  \right. $

\label{subsec:LCS}

\subsection{最长公共子字符串}
\cite{pp}15.5.9。与子字符\ref{subsec:LCS}的区别在于子串连续。将两个源字符串连接在一起，记录分隔点的位置，转换为求解最长重复短语的问题(\ref{problem:maxlenphrase})，区别在于扫描后缀数组时，如果当前后缀和下一个后缀出自相同的源字符串，则跳过。通过比较当前后缀对应的位置和分隔点的位置，可判断出该后缀出自哪个串。使用``异或''操作判断两个后缀是否出自同串。


\subsection{字符串相似度}
\cite{bop}3.3。相似度为最小的变换次数(记$\delta$, 单字符增、删、换)的倒数。
曾认为可先求LCS(\ref{subsec:LCS})，不妥。 简记A[x\ldots A.lenght-1]为A[x], 
\begin{displaymath}
   \delta(A[x], B[y])=
   \left\{
   \begin{array}{l}
       D[x+1][y+1], A[x]=B[y] \\ 
       min\{\delta[x][y+1], \delta[x][y+1], \delta[x+1][y+1] \}, A[y] \ne B[y]
   \end{array} 
    \right.
\end{displaymath}
\cite{bop}上程序写的大概是
\begin{math}
       min\{\delta[x+1][y+2], \delta[x+2][y+1], \delta[x+2][y+2] \}, A[y] \ne B[y]
\end{math}
,我认为不太正确。存在重复计算，可优化。

\subsection{包含所有关键词的最短摘要}
\cite{bop}3.5。枚举所有报文段($O(N^2)$)，枚举的过程中检查是否包含所有M个关键词($O(N^{2} \cdot M)$)。作为优化，\cite{bop}提出只考虑以关键词为开端的报文段。本题以搜索引擎为背景，个人认为不适合空间复杂度较高的算法，因此，不适合预处理报文，比如标记关键词在报文中的位置。检查任意报文分词是否为关键字的复杂度为$O(M)$。


\subsection{字符串中只出现一次的字符}
\cite{ms100}17。基于ASCII字符值域有限的特性，建立一长度255的数组，保存每个字符出现的次数。


\subsection{比特字符串排序}
\cite{pp}11.5.5。可变长位字符串排序，x[0\ldots n-1]每项包含整数length和指向数组bit[0\dots length-1]的指针，设bit[i]返回第i个bit的值(0或1)。 首先将长度小于递归深度的字符串移动到最左，再利用快速排序的Lomuto划分(参\ref{summary:quicksort})，将剩余部分划分成两部分，分布递归，检查下一位。

\begin{lstlisting}[language=C]
void bsort(l,u,depth)
    if l >= u return
    for i in [l, u]
	if x[i].length < depth
	    swap(i, l++)
    m = l
    for i in [l, u]
	if x[i].bit[depth] &=&  0
	    swap(i, m++)
    
    bsort(l, m-1, depth+1)
    bsort(m, u, depth+1)
\end{lstlisting}

一开始用bsort(0,n-1,1)调用该函数。运行时间正比与待排序数据量，即各字符串长度总和。swap移动的是字符串指针而非字符串本身。 \cite{self}认为该代码有误，除非bit的索引从1而非零开始。

\subsection{中缀表达式转为后缀表达式}
初始化一个空堆栈，将结果字符串变量置空。
从左到右读入中缀表达式，每次一个字符。
如果字符是操作数，将它添加到结果字符串。
如果字符是个操作符，弹出（pop）栈中操作符，直至遇见开括号（opening parenthesis）、优先级较低的操作符或者同一优先级的右结合符号。把这个操作符压入（push）堆栈。
如果字符是个开括号，把它压入堆栈。
如果字符是个闭括号（closing parenthesis），在遇见开括号前，弹出所有操作符，然后把它们添加到结果字符串。
如果到达输入字符串的末尾，弹出所有操作符并添加到结果字符串。




















