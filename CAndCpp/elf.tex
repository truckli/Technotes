%!Mode:: "TeX:UTF-8"
 

\section{ELF文件布局}
在ELF格式的可执行文件中，全局内存包括三种：bss、data和rodata。

bss代表Block Storage Start，是指那些没有初始化的和初始化为0的全局变量。
如\verb$int bss_array[1024 * 1024] = {0};$。
变量\verb$bss_array$的大小为4M，而可执行文件的大小只有5K。 
由此可见，bss类型的全局变量只占运行时的内存空间，而\textbf{不占}文件空间。

data指那些初始化过（非零）的非const的全局变量。
如果数据全是零，为了优化考虑，编译器把它当作bss处理。
data类型的全局变量是即占文件空间，又占用运行时内存空间的。
data的例子如:

\verb$int data_array[1024 * 1024] = {1};$


rodata的意义同样明显，ro代表read only，即只读数据(const)。
常量不一定就放在rodata里，有的立即数直接编码在指令里，存放在代码段(.text)中。
对于字符串常量，编译器会自动去掉重复的字符串，保证一个字符串在一个可执行文件(EXE/SO)中只存在一份拷贝。
rodata是在多个进程间是共享的，这可以提高空间利用率。
在有的嵌入式系统中，rodata放在ROM(如norflash)里，运行时直接读取ROM内存，无需要加载到RAM内存中。
把在运行过程中不会改变的数据设为rodata类型的，是有很多好处的：在多个进程间共享，可以大大提高空间利用率，甚至不占用RAM空间。同时由于rodata在只读的内存页面(page)中，是受保护的，任何试图对它的修改都会被及时发现，这可以帮助提高程序的稳定性。

\subsection{ABI}
应用二进制接口（英语：application binary interface，缩写为 ABI）描述了应用程序（或者其他类型）和操作系统之间或其他应用程序的低级接口。

ABI涵盖了各种细节，如：
\begin{itemize}
\item 数据类型的大小、布局和对齐;
\item 调用约定（控制着函数的参数如何传送以及如何接受返回值），例如，是所有的参数都通过栈传递，还是部分参数通过寄存器传递；哪个寄存器用于哪个函数参数；通过栈传递的第一个函数参数是最先push到栈上还是最后；
\item 系统调用的编码和一个应用如何向操作系统进行系统调用；
\item 以及在一个完整的操作系统ABI中，目标文件的二进制格式、程序库等等。
\end{itemize}
一个完整的ABI，像Intel二进制兼容标准（iBCS），允许支持它的操作系统上的程序不经修改在其他支持此ABI的操作系统上运行。

其他的ABI标准化了一些细节，包括C++ 名称修饰 ,和同一个平台上的编译器之间的调用约定，但是不包括跨平台的兼容性。

ABI不同于应用程序接口（API），API定义了源代码和库之间的接口，因此同样的代码可以在支持这个API的任何系统中编译，然而ABI允许编译好的目标代码在使用兼容ABI的系统中无需改动就能运行。 在Unix风格的操作系统中，存在很多运行在同一硬件平台上互相相关但是不兼容的操作系统（尤其是Intel 80386兼容系统）。有一些努力尝试标准化ABI，以减少销售商将程序移植到其他系统时所需的工作。然而，直到现在还没有很成功的例子，虽然Linux标准化工作组正在为Linux做这方面的努力。