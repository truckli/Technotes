%!Mode:: "TeX:UTF-8"
\section{整数/浮点数运算}

两个整数作\verb+&&,||,!+逻辑运算只有0和1两种结果。做\verb+&,|,^,~+等位运算，相当于每一bit分别运算,注意取反运算的结果与整数本身的位数有关。



\subsection{bit操作技巧}
设\verb$P = 2^s, M = P - 1$。M常被称作Mask;s被称作shift。

对齐运算：round-up(将整数x按P对齐的一种方式): \verb$((x) + M) & (~M)$; round-down: \verb$(x) & (~M)$。

buffer适配(为长度为x的对象分配内存，但需P倍数):\verb$((x) + M) >> s $。
更一般地，将[0,n]整数分割到长度为P的桶中，如不要求round-up方式，则x所在桶为\verb$(x) >> s $，x在桶中位次\verb$x & M$。注意
求桶位次运算和对齐运算的区别，对齐运算和桶分配运算的关联。桶分配相当于除法，桶位次相当于求模。

由M推导s:\verb$for(s=0,p=1;p < P;s++, p <<= 1);$。如果M并非2的某个幂，那么该式求出的p为恰好大于P的某个幂。

除去x的二进制表示的最末尾的1：\verb|(x) &((x)-1)|。

将0到N之间的数字用位图表示,实现按位操作:类似桶分配操作，一个32位int是一个桶，P=32：
\begin{lstlisting}[language=C++]
#define P 32
#define s 5
#define M 0x1F
int a[1+N/32];
#define set(i) a[i>>s] |= (1 << (i & M))
#define clr(i) a[i>>s] &= ~(1 << (i & M))
#define test(i) (a[i>>s] & (1 << (i & M)))
\end{lstlisting}


\subsection{补码(Two's Complement)}
应区分“\textbf{补码运算}”和“\textbf{补码表示}”。

\textbf{补码运算}为反码(One's Complement)运算加1。

正数的\textbf{补码表示}等同于其二进制表示，而正数的\textbf{补码运算}结果为一负数的\textbf{补码表示}。\textbf{补码运算}相当于求该数的相反数的\textbf{补码表示}。
\textbf{补码表示}的范围是$-2^{N-1}$到$2^{N-1}-1$。而反码(One's Complement)的表示范围是$-(2^{N-1}-1)$到$2^{N-1}-1$

\textbf{补码运算}的溢出会被忽略。对零作\textbf{补码运算}，会发生上溢，忽略上溢后仍是零。

一个数同其\textbf{补码运算}结果(等同于其相反数的\textbf{补码表示})相加(作无符号加法)，结果为$2^N$。

一个数同其反码运算结果相加(作无符号加法)，结果为$2^N-1$。


\subsection{负数右移}
\cite{krc}A.7.8。
移位运算符<<和>>遵循从左到右的结合性。每个运算符的各操作数都必须为整型,并且遵循整型提升原则。结果的类型是提升后的左操作数的类型。如果右操作数为负值,或者大于或等于左操作数类型的位数,则结果没有定义。

在对unsigned 类型的无符号值进行右移位时,左边空出的部分将用0填补;当对 signed 类型的带符号值进行右移时,某些机器将对左边空出的部分用符号位填补(即“算术移位”),而另一些机器则对左边空出的部分用0填补(即“逻辑移位”)。 

unsigned char类型的0xA2右移一位得0x51，而char类型的0xA2右移1位可能为0xD1(gcc验证)。

\subsection{二进制反码运算符}
一元运算符~的操作数必须是整型,结果为操作数的二进制反码。在运算过程中需要对操作数进行整型提升。如果操作数为无符号类型,则结果为提升后的类型能够表示的最大值减去操作数的值而得到的结果值。如果操作数为带符号类型,则结果的计算方式为:将提升后的操作数转换为相应的无符号类型,使用运算符~计算反码,再将结果转换为带符号类型。结果的类型为提升后的操作数的类型。


\subsection{台湾某CPU厂商面试题}
\begin{lstlisting}[language=C++]
    #include <iostream>
    using namespace std;
    int main()
    {
	unsigned char a = 0xA5;
	unsigned char b = ~a>>4+1;
	//cout << b << endl;
	printf(``b=%d\n'', b);
	return 0;
    }
\end{lstlisting}

本题有多处陷阱，一是移位运算的优先级很低，低于加法，因此~a实际上是右移5位，而非右移4位再加1；第二，a取反时应作整型提升，变为有符号数int型；第三，有符号数右移运算的结果实际上取决于实现，本题不妥；第四，b作为无符号数，打印前整型提升，却也不会将符号位进行扩展。

a整型提升后为0x000000a5，取反后为0xffffff5a，假设是算数移位，需要符号扩展，则右移5位得0xfffffffa，b的值为0xfa，整型提升后的值为0x000000fa。按照\%d打印为250。


如果将b强制类型转换为char型，再打印(\lstinline!printf(``%d\n'', (char)b);!)，则整型提升结果为0xfffffffa，打印结果为-6(将任何整数转换为带符号类型时, 如果它可以在新类型中表示出来, 则其值保持不变, 否则它的值同具体的实现有关, 参\cite{self}\ref{typeConv}, \cite{krc}A.6.2)。 

对b的打印也这样理解:\%d如实打印参数的符号，0xfa作为char类型为负数-6，作为unsigned char则为无符号数250，故而有上述结果。

\subsection{类型数值范围}
一个典型的32位PC上，long和int都是4字节，long long为8字节，float为4字节，double为8字节，long double为12字节，short为2字节，\verb$size_t,pid_t$为4字节。
32位无符号整数可表示的最大数字大于40亿，有符号整数能表示到20亿以上。

long long是C99新增的，C++标准委员会又将long long纳入C++11标准。
在C++11中，标准要求long long整型可以在不同平台上有不同的长度，但至少有64位。

limits.h头文件（C++中为<climits>）定义了int，long等类型能表示范围上下限，如
INT\_MAX, LONG\_MIN, SHORT\_MIN, USHRT\_MAX, LLONG\_MIN、LLONG\_MAX和ULLONG\_MIN。

stdint.h头文件定义了\verb$uint32_t$等类型的范围上下限，如INT8\_MAX，INT32\_MIN等。

\subsection{类型转换}

在一个表达式中,凡是可以使用整型的地方都可以使用带符号或无符号的字符、短整型或整型位字段,还可以使用枚举类型的对象。如果原始类型的所有值都可用int 类型表示, 则其值将被转换为int 类型;否则将被转换为unsigned int 类型。这一过程称为\textbf{整型提升(integral promotion)} 。

将任何整数转换为某种指定的无符号类型数的方法是:以该无符号类型能够表示的最大值加 1 为模,找出与此整数同余的最小的非负值。在对二的补码表示中,如果该无符号类型 的位模式较窄,这就相当于左截取;如果该无符号类型的位模式较宽,这就相当于对带符号 值进行符号扩展和对无符号值进行 0 填充。 将任何整数转换为带符号类型时,如果它可以在新类型中表示出来,则其值保持不变, 否则它的值同具体的实现有关。 

将一个精度较低的浮点值转换为相同或更高精度的浮点类型时,它的值保持不变。将一个较高精度的浮点类型值转换为较低精度的浮点类型时,如果它的值在可表示范围内,则结果可能是下一个较高或较低的可表示值。如果结果在可表示范围之外,则其行为是未定义的。 


许多运算符都会以类似的方式在运算过程中引起转换,并产生结果类型。其效果是将所有操作数转换为同一公共类型,并以此作为结果的类型。这种方式的转换称为普通算术类型转换。


类型转换顺序：
long double -> double -> float -> integral promotion -> ulong -> long,uint -> int

将浮点数赋值给整数，相当于取整。









