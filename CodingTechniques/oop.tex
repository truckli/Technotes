%!Mode:: "TeX:UTF-8"
\section{面向对象编程与设计模式}
\subsection{面向对象思想}
面向对象的三大特征：封装，继承，多态。

面向对象和基于对象的区别是，后者不涉及多态。

面向对象的五个基本原则：
\begin{description}
  \item [单一职责原则（Single-Resposibility Principle）]可以看做是低耦合、高内聚在面向对象原则上的引申
  \item [开放封闭原则（Open-Closed principle）]对扩展开放，对修改封闭的。
  \item [Liskov替换原则（Liskov-Substituion Principle）]子类必须能够替换其基类。
  \item [依赖倒置原则（Dependecy-Inversion Principle）] 其核心思想是：依赖于抽象。具体而言就是高层模块不依赖于底层模块，二者都同依赖于抽象；抽象不依赖于具体，具体依赖于抽象。抽象的稳定性决定了系统的稳定性，因为抽象是不变的，依赖于抽象是面向对象设计的精髓，也是依赖倒置原则的核心。依赖于抽象，就是对接口编程，不要对实现编程。
  \item [接口隔离原则（Interface-Segregation Principle）]使用多个小的专门的接口，而不要使用一个大的总接口。
\end{description}

\subsection{5个创建型模式}
\begin{description}
\item [ABSTRACT FACTORY(抽象工厂)]别名：Kit。
提供一个创建一系列相关或相互依赖对象的接口,而无需指定它们具体的类。
它使得易于交换产品系列，有利于产品的一致性，但难以支持新种类的产品。
抽象工厂类可用工厂方法实现，也可用Prototype实现。一个具体的工厂可以是Singleton。
\item [BUILDER(生成器)]
将一个复杂对象的构建与它的表示分离,使得同样的构建过程可以创建不同的表示。
\item [FACTORY METHOD(工厂方法)]别名:虚构造器( Virtual Constructor)。
定义一个用于创建对象的接口,让子类决定实例化哪一个类。 Factory Method使一个类的实例化延迟到其子类。
\item [PROTOTYPE(原型)]
用原型实例指定创建对象的种类,并且通过拷贝这些原型创建新的对象。
\item [SINGLETON(单件)]保证一个类仅有一个实例,并提供一个访问它的全局访问点。
不死鸟单体(Phoenix Singleton)定义了单体的销毁操作，可以死而复生。
\end{description}

\subsection{7个结构型模式}
\begin{description}
\item [ADAPTER(适配器)]
别名：Wrapper。将一个类的接口转换成客户希望的另外一个接口,使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。适配器模式和外观模式的区别是，前者复用既有接口，后者定义新接口。
\item [BRIDGE(桥接)]
别名: Handle/Body。将抽象部分与它的实现部分分离,使它们都可以独立地变化。
\item [COMPOSITE(组合)]
将对象组合成树形结构以表示“部分 -整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致性。
例如：多个层次的视图部件组合成一个文档。
\item [DECORATOR(装饰)]
别名：Wrapper。动态地给一个对象添加一些额外的职责。就增加功能来说, Decorator模式相比生成子类更为灵活。例如：一些GUI工具箱为窗口组件添加图形装饰。装饰模式和组合模式具有类似的结构图，说明它们都基于递归组合来组织可变数量的对象。但组合模式旨在构造类使得多个相关对象能够以统一方式处理，多重对象被当作一个对象处理。
\item [FACADE(外观)]
为子系统中的一组接口提供一个一致的界面, 该模式定义了一个高层接口,这个接口使得这一子系统更加容易使用。例如：编译器前端。
\item [FLYWEIGHT(享元)]
运用共享技术有效地支持大量细粒度的对象。例如文档编辑器为每种字符(如128个ASCII字符)共享一个flyweight对象。享元模式常伴随引用计数和垃圾回收。可以用享元模式实现State和Strategy对象。
\item [PROXY(代理)]
别名:Surrogate。为其他对象提供一种代理以控制对这个对象的访问。常见场景：远程代理(隐藏对象不在本地的事实)、虚代理(可按需创建对象，如加载文档时用只知道图片大小的ImageProxy代理不在第一页的图片)、保护代理和智能指针。后两种情况允许访问一个对象前有一些附加的HouseKeeping Task。
\end{description}

\subsection{11个行为型模式}
\begin{description}
\item [CHAIN OF RESPONSIBILITY(职责链)]
使多个对象都有机会处理请求,从而避免请求的发送者和接收者之间的耦合关系。
	将这些对象连成一条链,并沿着这条链传递该请求,直到有一个对象处理它为止。
	如用户点击帮助时，按照按钮 - 对话框 - 应用程序顺序向UI中的一个组件请求帮助信息。
\item [COMMAND(命令)]
别名：动作(Action),事务(Transaction)。
将请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作。
Command对象将接受者对象绑定于一个动作，并调用接受者的动作。命令模式将操作的调用者和接受者进行解耦。可用于实现GUI菜单。
\item [INTERPRETER(解释器)]给定一个语言,定义它的文法的一种表示,并定义一个解释器,这个解释器使用该表示来解释语言中的句子。
用于语法树分析。只适用于简单的文法和对效率要求不高的场合。
\item [ITERATOR(迭代器)]
别名：游标(Cursor)。提供一种方法顺序访问一个聚合对象中各个元素 , 而又不需暴露该对象的内部表示。
\item [MEDIATOR(中介者)]
用一个中介对象来封装一系列的对象(Colleague)交互。中介者使各对象不需要显式地相互引用,从而使其耦合松散,而且可以独立地改变它们之间的交互。该模式用一对多交互代替多对多交互从而简化对象协议，更容易维护和扩展。例如，一个对话框可以跟多个相互约束的UI控件通信。外观模式为一个子系统提供了一个方便的接口，协议是单向的，而中介者对象则提供了双向交互的协作行为。
\item [MEMENTO(备忘录)]
别名：Token。
在不破坏封装性的前提下,捕获一个对象(原发器,originator)的内部状态, 使得负责人(Caretaker)对象在原发器之外保存这个状态为一个备忘录对象。这样以后负责人对象就可将备忘录对象交给原发器，使原发器恢复到原先保存的状态。该模式简化了原发器，因为状态管理工作不再由原发器负责。使用备忘录可能代价很高。
\item [OBSERVER(观察者)]
别名：依赖(Dependents), 发布-订阅(Publish-Subscribe)。定义对象间的一种一对多的依赖关系 ,当一个对象(目标，subject)的状态发生改变时 , 所有依赖于它的对象(观察者，observer)都得到通知并被自动更新。Subject提供注册和删除observer的接口，observer提供更新通知接口。
例如，Excel中表格中数据改变时，柱状图也相应地改变了。
\item [STATE(状态)]
别名：状态对象(Objects for States)。允许一个对象(Context对象)在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类。
需要实现若干State对象，定义一个接口以封装Context的一个特定状态相关的行为。
State对象将与特定状态相关的行为局部化，且将不同状态的行为分割开，并使得Context对象状态转换显式化、原子化。
如果State对象没有实例变量，则可以作为享元进行共享。
\item [STRATEGY(策略)]
别名：政策(Policy)。
定义一系列的算法 ,把它们一个个封装起来 , 并且使它们可相互替换。本模式使得算法可独立于使用它的客户而变化。
Strategy类层次实现一批算法，Context类用strategy对象进行配置，维护对strategy对象的引用，并定义接口让strategy对象访问它的数据。
该模式是对象继承的替代方法，消除了一些条件语句。客户可以自行选择合适的策略，从而也必须了解不同策略的区别。

\item [TEMPLATE METHOD(模板方法)]
定义一个操作中的算法的骨架,而将一些步骤延迟到子类中。使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。
在基类中定义一个模板方法，调用原语操作。在派生类中重写原语操作。在C++中，模板方法可定义为protected非虚成员函数，原语操作为virtual函数。模板方法通过继承来改变算法的一部分，而Strategy模式使用委托来改变整个算法。
\item [VISITOR(访问者)]
表示一个作用于某对象结构（如语法树）中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。
适用情形：一个对象结构包含很多类对象, 而你想对这些对象实施一些依赖于其具体类的操作;定义对象结构的类很少改变,但经常需要在此结构上定义新的操作。
改变对象结构类需要重定义对所有访问者的接口,这可能需要很大的代价。如果对象结构类经常改变,那么可能还是在这些类中定义这些操作较好。



\end{description}


\subsection{委托}
委托(delegation)是对象组合的特例，它使得组合具有与继承相同的复用能力。
State, Strategy和Visitor使用了委托。
State, Strategy都是通过改变受托对象来改变委托对象的行为。
Visitor中，对象结构每个元素上的操作都被委托到Visitor对象。
Mediator，Bridge和Chain of Responsibility则未必那么多地(less heavily)用到了委托。(猜测委托的涵义在于自己不怎么干活)



\subsection{MVC}
控制器掌管着用户的请求，它的主要功能就是调用并协调需要的资源/对象来执行用户请求。
通常控制器会为任务调用合适的模型，以及选择合适的视图。
模型是指运用于数据之上的数据规则和数据内容，它一般对应于应用程序所要管理的对象。
在软件系统中，任何事物都可以被抽象成可以对其以某种方式进行处理的数据模型。

MVC跟设计模式有什么联系？\\
MVC不是一种设计模式（design pattern），它是一种架构模式。
也有人说，MVC模式是一种复合模式（复合设计模式为两种或两种以上设计模式结合在一起）。
MVC中的模型（MODEL）采用了观察者模式。也就是说，如果模型状态改变，对应的视图和控制器状态也会随之改变；MVC中的控制器（Controller）采用了策略模式，视图将行为委托给了控制器，并且可以动态的改变行为，也就是动态的更换控制器；MVC中的视图采用了组合模式，视图中的窗口、面板、按钮、标签等。这些组件有的是组合节点，有的是叶子节点，利用组合模式可以让这些节点采取统一的处理方式。

MVC的好处是什么？\\
易扩展，易维护。MVC的一个最明显好处就是它将视图展示和应用逻辑清晰的分离开来。



\subsection{DAO}

In computer software, a
\href{https://en.wikipedia.org/wiki/Data_access_object}{data access object (DAO)}
 is an object that provides an abstract interface to some type of database or other persistence mechanism.
By mapping application calls to the persistence layer, DAO provide some specific data operations without exposing details of the database. 
This isolation supports the Single responsibility principle. 
It separates what data accesses the application needs, in terms of domain-specific objects and data types (the public interface of the DAO), from how these needs can be satisfied with a specific DBMS, database schema, etc. (the implementation of the DAO).
Although this design pattern is equally applicable to the following: (1- most
programming languages; 2- most types of software with persistence needs; and 3- most types of databases) it is traditionally associated with Java EE applications and with relational databases .



\subsection{REST}

In computing, \href{https://en.wikipedia.org/wiki/Representational_state_transfer}{representational state transfer (REST)} 
is the software architectural style of the Web.
More precisely, REST is an architectural style consisting of a coordinated set
of architectural constraints applied to components, connectors, and data elements, within a distributed hypermedia system. 
REST ignores the details of component implementation and protocol syntax in order to focus on the roles of components, the constraints upon their interaction with other components, and their interpretation of significant data elements.

The term was introduced and defined in 2000 by Roy Fielding in his doctoral dissertation at UC Irvine.
Fielding used REST to design HTTP 1.1 and Uniform Resource Identifiers (URI).
To the extent that systems conform to the constraints of REST they can be called \textbf{RESTful}.
RESTful systems typically, but not always, communicate over Hypertext Transfer Protocol (HTTP) with the same HTTP verbs (GET, POST, PUT, DELETE, etc.) that web browsers use to retrieve web pages and to send data to remote servers.[4] REST systems interface with external systems as web resources identified by Uniform Resource Identifiers (URIs),
 for example /people/tom, which can be operated upon using standard verbs such as DELETE /people/tom.

The formal REST constraints are:
\begin{itemize}
  \item Client–server
  \item Stateless
  \item Cacheable
  \item Layered system
  \item Code on demand (optional)
  \item Uniform interface
  \begin{itemize}
    \item Identification of resources
    \item Manipulation of resources through these representations
    \item Self-descriptive messages
    \item Hypermedia as the engine of application state(HATEOAS)
\end{itemize}
\end{itemize}

Web service APIs that adhere to the REST architectural constraints are called \textbf{RESTful APIs}.
Unlike SOAP-based web services, there is no "official" standard for RESTful web APIs.
This is because REST is an architectural style, while SOAP is a protocol.
Even though REST is not a standard per se, most RESTful implementations make use of standards such as HTTP, URI, JSON, and XML.

The PUT and DELETE methods are referred to as idempotent, meaning that the
operation will produce the same result no matter how many times it is repeated. 
The GET method is a safe method (or nullipotent), meaning that calling it produces no side-effects.







