%!Mode:: "TeX:UTF-8"
\section{内存分配模式}
\label{sec:memallocidioms}
\url{http://blog.csdn.net/absurd/article/details/937803}
《POSA》中根据模式粒度把模式分为三类：架构模式、设计模式和惯用手法。其中把分层模式、管道过滤器和微内核模式等归为架构模式，把代理模式、命令模式和出版-订阅模式等归为设计模式，而把引用计数等归为惯用手法。这三类模式间的界限比较模糊，在特定的情况，有的设计模式可以作为架构模式来用，有的把架构模式也作为设计模式来用。
内存分配的惯用手法包括：
\begin{itemize}
\item 预分配。预分配机制比较常见，多见于一些带buffer的容器实现中，比如像vector和string等。
\item 对象引用计数
\item 写时拷贝(COW)。OS内核创建子进程的过程是最常见而且最有效的COW例子
\item 固定大小分配。这种方式通常也叫做缓冲池(pool)分配。缓冲池(pool)先分配一块或者多块连续的大块内存，把它们分成N块大小相等的小块内存，然后进行二次分配。固定大小分配运用比较广泛，差不多所有的内存管理器都用这种方法来对付小块内存，比如glibc、STLPort和linux的slab等。
\item 会话缓冲池分配(Session Pool)。它基于多次分配一次释放的策略，在过程开始时创建会话缓冲池(Session Pool)，这个过程中所有内存分配都通过会话缓冲池(Session Pool)来分配，当这个过程完成时，销毁掉会话缓冲池(Session Pool)，即释放这个过程中所分配的全部内存。会话缓冲池分配并不是太常见，apache采用的这种用法。
\end{itemize}

Glibc分配算法思想（参\ref{sec:glibc-malloc}）：
\begin{itemize}
\item 小于等于64字节：用pool算法分配
\item 64到512字节之间：在最佳凭配算法分配和pool算法分配中取一种合适的
\item 大于等于512字节：用最佳凭配算法分配
\item 大于等于128K：直接调用OS提供的函数(如mmap)分配
\end{itemize}


SGI STL有两级内存分配器，第一级简单封装malloc和free，第二级回应用户的内存分配请求，重点解决小额内存块问题。
当区块足够大，超过128字节时，交给第一级分配器处理。维护了16个内存池，块大小从8到128，均按照8字节对齐。还有一个为16个内存池蓄水的总池，总池只分配，不回收。当内存不够时还做了许多精细处理，包括各池互借等。
池块节点的维护也很巧妙，因为已被分配的块不需要维护节点信息，而未必分配的块不包含用户数据，可用union来管理：
\begin{lstlisting}[language=C++]

union obj{
  union obj *free_list_link;
  char client_data[1];
};
};

\end{lstlisting}

OCTEON FPA内存池有8个，对应8种不同的块大小，用硬件分配释放，也属于预分配思想。

Hili框架内存池为动态创建，池块大小随意，对齐成8字节，用链表维护。由于是为任意应用类型开辟新池，实际上是一种slab分配器。
STL的内存池用于形形色色的对象创建，而Hili内存池各层次会话结构缓存，目标不同。

boost.pool库提供了四种内存池：pool用于POD(Plain Old Data)类型，object\_pool用于分配类实例，还有单件内存池singleton\_pool和可用于标准库的pool\_alloc。
pool类采用了定长内存池和一次性释放思想，在pool销毁时自动释放。object\_pool模板类对pool进行了保护继承，其construct和destroy接口在内存分配的同时还调用类的构造和析构函数。
singleton\_pool本身是个单件，所有接口都是静态的，并提供线程安全，它为POD类型分配内存，分配的块长通过模板参数而非构造函数参数来指定。


\section{Java内存泄露}
在Java中，内存泄漏就是存在一些被分配的对象，这些对象有下面两个特点，首先，这些对象是可达的，即在有向图中，存在通路可以与其相连；其次，这些对象是无用的，即程序以后不会再使用这些对象。如果对象满足这两个条件，这些对象就可以判定为Java中的内存泄漏，这些对象不会被GC所回收，然而它却占用内存。

在C++中，内存泄漏的范围更大一些。有些对象被分配了内存空间，然后却不可达，由于C++中没有GC，这些内存将永远收不回来。在Java中，这些不可达的对象都由GC负责回收，因此程序员不需要考虑这部分的内存泄露。

通过分析，我们得知，对于C++，程序员需要自己管理边和顶点，而对于Java程序员只需要管理边就可以了(不需要管理顶点的释放)。通过这种方式，Java提高了编程的效率。

Java中也有内存泄漏，但范围比C++要小一些。因为Java从语言上保证，任何对象都是可达的，所有的不可达对象都由GC管理。



\section{内存调试手段}

\subsection{应用程序层次的防御}
\textbf{对付内存泄露}：重载内存管理函数，在分配时，把这块内存的记录到一个链表中，在释放时，从链表中删除吧，在程序退出时，检查链表是否为空，如果不为空，则说明有内存泄露，否则说明没有泄露。当然，为了查出是哪里的泄露，在链表还要记录是谁分配的，通常记录文件名和行号就行了。

\textbf{对付内存越界/野指针}：
只能做到部分防御。malloc返回的内存在首尾在加保护边界值，随时检测是否被越界改写。被free的时候再用其他标志覆盖，随时检测一个指针是否是已被free的内存。

\subsection{编译器层次的防御}
如gcc的bounds checker在编译时修改源程序，对所有的内存操作做簿记(分配、释放、读写)，管理所有的内存块(堆、栈、全局、静态)，拦截所有的指针操作(p++,p=a[n])。Valgrind,purify通过修改可执行文件做相似的事情。











